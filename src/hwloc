/* vi: set filetype=cpp : */
#pragma once

#include <memory>
#include <stdexcept>
#include <utility>
#include <string>
#include <vector>
#include <iostream>

#include <hwloc.h>

namespace hwloc {

class bitmap {
  hwloc_bitmap_t set_ = nullptr;

  class bitmap_iterator {
    const bitmap *b_;
    std::pair<unsigned, int> pos_;

    friend class bitmap;
    bitmap_iterator(const bitmap *const b) : b_(b), pos_(0, b_->first()) {}

  public:
    bitmap_iterator() : b_(nullptr), pos_(0, -1) {}
    bool operator==(const bitmap_iterator &r) const {
      return (b_ == r.b_ && pos_ == r.pos_) ||
             (b_ == nullptr && r.pos_.second == -1) ||
             (r.b_ == nullptr && pos_.second == -1);
    }

    bool operator!=(const bitmap_iterator &r) const { return !(*this == r); }
    const std::pair<unsigned, int> &operator*() const { return pos_; }

    bitmap_iterator &operator++() {
      if (b_ != nullptr) {
        ++pos_.first;
        pos_.second = b_->next(pos_.second);
      }
      return *this;
    }
  };

  friend class topology;

  struct bitmap_scanf_tag {};

  hwloc_bitmap_t get() const { return set_; }

public:
  using iterator = bitmap_iterator;
  using const_iterator = bitmap_iterator;

  struct list_tag : bitmap_scanf_tag {
    static constexpr auto scanf = hwloc_bitmap_list_sscanf;
  };
  struct taskset_tag : bitmap_scanf_tag {
    static constexpr auto scanf = hwloc_bitmap_taskset_sscanf;
  };

  bitmap() : set_(hwloc_bitmap_alloc()) {}
  bitmap(hwloc_const_bitmap_t bitmap) : set_(hwloc_bitmap_dup(bitmap)) {}
  explicit bitmap(const char *str) : bitmap() {
    const int err = hwloc_bitmap_sscanf(set_, str);
    if (err) {
      using namespace std::string_literals;
      hwloc_bitmap_free(set_);
      throw std::runtime_error("Error parsing bitmap string "s + str);
    }
  }

  template <typename T> bitmap(const char *str, T) : bitmap() {
    static_assert(std::is_base_of<bitmap_scanf_tag, T>::value,
                  "Only taskset_tag or list_tag can be used here.");
    const int err = T::scanf(set_, str);
    if (err) {
      using namespace std::string_literals;
      hwloc_bitmap_free(set_);
      throw std::runtime_error("Error parsing bitmap string "s + str);
    }
  }

  ~bitmap() {
    if (set_ != nullptr) {
      hwloc_bitmap_free(set_);
    }
  }

  bitmap(const bitmap &r) : set_(hwloc_bitmap_dup(r.set_)) {}
  bitmap(bitmap &&r) {
    using namespace std;
    swap(set_, r.set_);
  }

  bitmap &operator=(const bitmap &r) {
    using namespace std;
    auto tmp = r;
    swap(*this, tmp);
    return *this;
  }

  bitmap &operator=(bitmap &&r) {
    using namespace std;
    swap(set_, r.set_);
    return *this;
  }

  bitmap &operator&=(const bitmap &r) {
    hwloc_bitmap_and(set_, set_, r.set_);
    return *this;
  }

  bitmap &operator|=(const bitmap &r) {
    hwloc_bitmap_or(set_, set_, r.set_);
    return *this;
  }

  friend bitmap operator&(const bitmap &l, const bitmap &r) {
    bitmap result;
    hwloc_bitmap_and(result.set_, l.set_, r.set_);
    return result;
  }
  
  friend bitmap operator|(const bitmap &l, const bitmap &r) {
    bitmap result;
    hwloc_bitmap_or(result.set_, l.set_, r.set_);
    return result;
  }

  explicit operator bool() const { return !hwloc_bitmap_iszero(set_); }

  bool isincluded(const bitmap &r) const {
    return hwloc_bitmap_isincluded(set_, r.set_);
  }
  bool isequal(const bitmap &r) const {
    return hwloc_bitmap_isequal(set_, r.set_);
  }
  bool isset(const unsigned id) const { return hwloc_bitmap_isset(set_, id); }

  bool intersects(const bitmap &r) const {
    return hwloc_bitmap_intersects(set_, r.set_);
  }


  int weight() const { return hwloc_bitmap_weight(set_); }
  unsigned size() const {
    const auto sz = weight();
    if (sz < 0) {
      throw std::runtime_error("Error getting size of bitmap");
    }
    return static_cast<unsigned>(sz);
  }
  int first() const { return hwloc_bitmap_first(set_); }
  unsigned first(int) const {
    const int tmp = hwloc_bitmap_first(set_);
    if (tmp < 0) {
      throw std::runtime_error("first(int) failed. No bit set in bitmap.");
    }
    return static_cast<unsigned>(tmp);
  }
  int next(const int prev) const { return hwloc_bitmap_next(set_, prev); }

  bitmap &singlify() {
    hwloc_bitmap_singlify(set_);
    return *this;
  }

  bitmap &set(const unsigned id) {
    hwloc_bitmap_set(set_, id);
    return *this;
  }

  std::string to_string() const {
    const int length = hwloc_bitmap_snprintf(nullptr, 0, set_);
    if (length < 0) {
      throw std::runtime_error("Error printing bitmap string");
    }
    std::vector<char> result(static_cast<unsigned>(length + 1));
    hwloc_bitmap_snprintf(result.data(), result.size(), set_);

    return std::string(result.begin(), result.end());
  }

  iterator begin() const { return iterator(this); }
  iterator end() const { return iterator(); }

  friend void swap(bitmap &r, bitmap &l) {
    using namespace std;
    swap(r.set_, l.set_);
  }

  friend std::ostream &operator<<(std::ostream &os, const bitmap &b) {
    return os << b.to_string();
  }
};

using cpuset = bitmap;

class topology {
  hwloc_topology_t topology_ = nullptr;

public:
  class depth {
    unsigned depth_;
    depth(const unsigned depth) : depth_(depth) {}
    friend class topology;
  };

  topology() {
    if (hwloc_topology_init(&topology_)) {
      throw std::runtime_error("hwloc_topology_init failed\n");
    }
  }

  ~topology() { hwloc_topology_destroy(topology_); }

  void load() {
    if (hwloc_topology_load(topology_)) {
      throw std::runtime_error("hwloc_topology_load() failed\n");
    }
  }

  bool is_thissystem() const { return hwloc_topology_is_thissystem(topology_); }

  cpuset get_topology_cpuset() const {
    return hwloc_topology_get_topology_cpuset(topology_);
  }

  depth get_type_or_below_depth(const hwloc_obj_type_t type) const {
    const int depth = hwloc_get_type_or_below_depth(topology_, type);
    if (depth < 0) {
      throw std::runtime_error("Error finding type: " + std::to_string(type));
    }

    return {static_cast<unsigned>(depth)};
  }

  unsigned get_nbobjs(const depth &d) const {
    return hwloc_get_nbobjs_by_depth(topology_, d.depth_);
  }

  hwloc_obj_t get_obj(const hwloc_obj_type_t type, const unsigned n) const {
    return hwloc_get_obj_by_type(topology_, type, n);
  }

  hwloc_obj_t get_obj(const depth &d, const unsigned idx = 0) const {
    return hwloc_get_obj_by_depth(topology_, d.depth_, idx);
  }

  hwloc_obj_t get_cache_covering_cpuset(const cpuset &set) const {
    return hwloc_get_cache_covering_cpuset(topology_, set.get());
  }

  cpuset get_cpubind() const {
    cpuset result;
    const int ret =
        hwloc_get_cpubind(topology_, result.set_, HWLOC_CPUBIND_THREAD);
    if (ret) {
      throw std::runtime_error("hwloc_get_cpubind() failed.");
    }

    return result;
  }

  cpuset get_last_cpu_location(
      const hwloc_cpubind_flags_t flags = HWLOC_CPUBIND_THREAD) const {
    cpuset result;
    const int ret = hwloc_get_last_cpu_location(topology_, result.set_, flags);
    if (ret) {
      throw std::runtime_error("hwloc_get_last_cpu_location() failed.");
    }
    return result;
  }

  void set_cpubind(const cpuset set,
                   const hwloc_cpubind_flags_t flags = HWLOC_CPUBIND_THREAD) {
    const auto err = hwloc_set_cpubind(topology_, set.set_, flags);
    if (err) {
      throw std::runtime_error("hwloc_set_cpubind() failed");
    }
  }

  [[deprecated]] hwloc_topology_t get() { return topology_; }
};

} // namespace hwloc
